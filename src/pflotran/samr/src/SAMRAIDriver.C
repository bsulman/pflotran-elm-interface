//
// $Id: test_gradient.C 1832 2005-08-23 21:10:00Z bphilip $
// $Revision: 1832 $
// $Date: 2005-08-23 15:10:00 -0600 (Tue, 23 Aug 2005) $
//

#include "SAMRAI_config.h"

#include <iostream>

#include <fstream>
using namespace std;

#include <sys/stat.h>

/*
 * SAMRAI headers.
 */
#include "BoundaryBox.h"
#include "BoxArray.h"
#include "BoxList.h"
#include "BergerRigoutsos.h"
#include "CartesianGridGeometry.h"
#include "CartesianPatchGeometry.h"
#include "CellData.h"
#include "CellVariable.h"
#include "FaceData.h"
#include "FaceVariable.h"
#include "GriddingAlgorithm.h"
#include "Index.h"
#include "tbox/InputDatabase.h"
#include "tbox/InputManager.h"
#include "IntVector.h"
#include "LoadBalancer.h"
#include "tbox/SAMRAI_MPI.h"
#include "Patch.h"
#include "PatchGeometry.h"
#include "tbox/PIO.h"
#include "RefineAlgorithm.h"
#include "RefineOperator.h"
#include "tbox/SAMRAIManager.h"
#include "StandardTagAndInitialize.h"
#include "tbox/Utilities.h"
#include "tbox/Timer.h"
#include "tbox/TimerManager.h"
#include "VariableContext.h"
#include "VariableDatabase.h"
#include "PETSc_SAMRAIVectorReal.h"
extern "C"{
#include "assert.h"
}

/*
 * Application header.
 */
#include "BoundaryConditionStrategy.h"
#include "BogusTagAndInitStrategy.h"

#include "RefinementBoundaryInterpolation.h"
#include "PflotranApplicationStrategy.h" 
#include "PflotranApplicationParameters.h" 
#include "CCellDoubleConstantRefine.h"
#include "CartesianCCellDoubleWeightedAverage.h"
#include "CartesianCSideDoubleWeightedAverage.h"
#include "CartesianCSideDoubleSum.h"
#include "CartesianCCellDoubleSum.h"
#include "fc_interface.h"
#include "SAMRAIDriver.h"
/*#include "pims_local_struct.h"*/
/*
 * Ghost cell width for variables that need them.
 */

#define GHOST_CELL_WIDTH (1)
int __argc_save;
char **__argv_save;

int main( int argc, char *argv[] ) 
{
   string input_file;
   string log_file;
   bool is_from_restart = false;
   
   tbox::Pointer<hier::PatchHierarchy<NDIM> > hierarchy;

   __argc_save = argc;
   __argv_save = argv;

   tbox::SAMRAI_MPI::init(&argc, &argv);
   tbox::SAMRAIManager::startup();

   PETSC_COMM_WORLD = SAMRAI::tbox::SAMRAI_MPI::getCommunicator();

   int ierr = PetscInitialize(&argc,&argv,PETSC_NULL,PETSC_NULL);

   PetscInitializeFortran();

   /*
    * Process command line arguments and dump to log file.
    */
   processCommandLine(argc, argv, input_file, log_file);

   tbox::PIO::logOnlyNodeZero(log_file);

   /*
    * Create input database and parse all data in input file.  This
    * parsing allows us to subsequently extract individual sections.
    */
   tbox::Pointer<tbox::Database> input_db = new tbox::InputDatabase("input_db");
   tbox::InputManager::getManager()->parseInputFile(input_file, input_db);

   tbox::Pointer<tbox::Database> app_database = input_db->getDatabase("PflotranApplicationStrategy");

   int mode =  app_database->getInteger("DriverMode");

   PflotranApplicationStrategy *pflotranApplication = NULL;

   /*
    * Setup the timer manager to trace timing statistics during execution
    * of the code.  The list of timers is given in the tbox::TimerManager
    * section of the input file.  Timing information is stored in the
    * restart file.  Timers will automatically be initialized to their
    * previous state if the run is restarted.  To reset timers to zero,
    * call the resetAllTimers() function as shown.
    */
   tbox::TimerManager::createManager(input_db->getDatabase("TimerManager"));
   if (is_from_restart) 
   {
      tbox::TimerManager::getManager()->resetAllTimers();
   }

   input_db->getDatabase("TimerManager")->printClassData(tbox::plog);
   
   BogusTagAndInitStrategy* test_object=NULL;
   
   if(mode==1)
     {
       
       /*
	* Create an application object.  Some TagAndInitStrategy must be
	* provided in order to build an object that specifies cells that
	* need refinement.  Here an empty object is provided, since a
	* prescribed set of refinement regions are read in from the input
	* file; it would be a useful exercise to fill in the
	* applyGradientDetector method and to generate custom refinement
	* regions.
	*/
       test_object = new BogusTagAndInitStrategy();
       
       /*
	* Create the AMR hierarchy and initialize it
	*/
       initializeAMRHierarchy(input_db,
			      test_object,
			      hierarchy);
              
       tbox::Pointer<geom::CartesianGridGeometry<NDIM> > grid_geometry = hierarchy->getGridGeometry();
       
       pdat::CCellDoubleConstantRefine<NDIM> *ccell_const_refine_op = new pdat::CCellDoubleConstantRefine<NDIM>();
       grid_geometry->addSpatialRefineOperator(ccell_const_refine_op);
       
       geom::CartesianCCellDoubleWeightedAverage<NDIM> *ccell_cons_coarsen_op = new geom::CartesianCCellDoubleWeightedAverage<NDIM>();
       grid_geometry->addSpatialCoarsenOperator(ccell_cons_coarsen_op);
       
       geom::CartesianCSideDoubleWeightedAverage<NDIM> *cside_cons_coarsen_op = new geom::CartesianCSideDoubleWeightedAverage<NDIM>();
       grid_geometry->addSpatialCoarsenOperator(cside_cons_coarsen_op);
       
       geom::CartesianCCellDoubleSum<NDIM> *ccell_sum_coarsen_op = new geom::CartesianCCellDoubleSum<NDIM>();
       grid_geometry->addSpatialCoarsenOperator(ccell_sum_coarsen_op);
       
       geom::CartesianCSideDoubleSum<NDIM> *cside_sum_coarsen_op = new geom::CartesianCSideDoubleSum<NDIM>();
       grid_geometry->addSpatialCoarsenOperator(cside_sum_coarsen_op);
       
       PflotranApplicationParameters *params  =new PflotranApplicationParameters(app_database);
       params->d_hierarchy = hierarchy;
       
       pflotranApplication = new PflotranApplicationStrategy(params);
              
       // create a RefinementBoundaryInterpolation object
       RefinementBoundaryInterpolation *cf_interpolant = new RefinementBoundaryInterpolation(hierarchy);
       cf_interpolant->setVariableOrderInterpolation(false);
       
       /*
	* Add the RefinementBoundaryInterpolation object
	*/
       pflotranApplication->setRefinementBoundaryInterpolant(cf_interpolant);       
     }
   
   void *p_pflotran_sim = NULL;

   /*
    * Initialize AMR hierarchy configuration and data on all patches
    * at initial time.  Close restart file after all simulation state
    * has been reconstructed.  Also, write initial state for
    * visualization.  Note that we also start a timer for the
    * simulation part of the main program.
    */
   static tbox::Pointer<tbox::Timer> main_timer = 
      tbox::TimerManager::getManager()->getTimer("apps::main::main");

   main_timer->start();
   
   f_create_simulation_(&p_pflotran_sim, (void **)&pflotranApplication);
   
   f_initialize_simulation_(&p_pflotran_sim);

#if 1   
   f_stepper_run_(&p_pflotran_sim);
#endif   
   /*
    * At conclusion of simulation, stop timer and deallocate objects.
    */
   main_timer->stop();

   f_simulation_destroy_(&p_pflotran_sim);
   
   tbox::TimerManager::getManager()->print();

   //   if(pflotranApplication!=NULL)  delete pflotranApplication;
   if(test_object) delete test_object;
   /* 
    * That's all, folks!
    */
   PetscFinalize();
   tbox::SAMRAIManager::shutdown();
   tbox::SAMRAI_MPI::finalize();

   return(0);
}

/*
************************************************************************
*                                                                      *
*  Parse command line arguments, returning name of input file and log  *
*  file.                                                               *
*                                                                      *
************************************************************************
*/
void processCommandLine(int argc, 
                        char *argv[], 
                        string& input_file, 
                        string& log_file)
{
  if ( (argc < 3) ) {
    tbox::pout << "USAGE:  " << argv[0] << " <input file> <log file> " << endl;
    exit(-1);
  } else {
    input_file = argv[1];
    log_file = argv[2];
  }

  return;
}

/*
************************************************************************
*                                                                      *
* Generate a patch hierarchy from information specified in input       *
* database.                                                            *
*                                                                      *
************************************************************************
*/
void initializeAMRHierarchy(tbox::Pointer<tbox::Database> &input_db,
			    mesh::StandardTagAndInitStrategy<NDIM>* user_tagging_strategy,
			    tbox::Pointer<hier::PatchHierarchy<NDIM> > &hierarchy)
{
   /*
    * Create geometry object.  This specifies the index space of the
    * coarsest level, as well as its physical (Cartesian) coordinates.
    */
   tbox::Pointer<geom::CartesianGridGeometry<NDIM> > grid_geometry = 
      new geom::CartesianGridGeometry<NDIM>("CartesianGeometry",
                                input_db->getDatabase("CartesianGeometry"));

   /*
    * Create patch hierarchy.
    */
   hierarchy = new hier::PatchHierarchy<NDIM>("PatchHierarchy", grid_geometry);

   /* 
    * A mesh::GriddingAlgorithm<NDIM> is used to build the initial grid hierarchy.
    * Classes for tagging cells that need refinement, generation of
    * boxes from these tagged cells, and load balancing the grid
    * hierarchy are needed to build the mesh::GriddingAlgorithm<NDIM>.
    *
    * First build the object used to tag cells that need refinement.
    */
    tbox::Pointer<mesh::StandardTagAndInitialize<NDIM> > error_detector = 
	new mesh::StandardTagAndInitialize<NDIM>( 
	    "CellTaggingMethod", 
	    user_tagging_strategy, 
	    input_db->getDatabase("StandardTagAndInitialize"));
    
   /*
    * Next, specify the built-in Berger-Rigoutsos method for
    * generating boxes from the tagged cells.
    */
   tbox::Pointer<mesh::BergerRigoutsos<NDIM> > box_generator = new mesh::BergerRigoutsos<NDIM>(); 

   /*
    * Next, specify the built-in uniform load balancer to distribute
    * patches across processors.
    */
   tbox::Pointer<mesh::LoadBalancer<NDIM> > load_balancer =
      new mesh::LoadBalancer<NDIM>(input_db->getDatabase("LoadBalancer"));

   /*
    * Finally, build the grid generator, registering the above
    * strategies for tagging cells, generating boxes, and load
    * balancing the calculation.
    */
   tbox::Pointer<mesh::GriddingAlgorithm<NDIM> > gridding_algorithm =
      new mesh::GriddingAlgorithm<NDIM>("GriddingAlgorithm",
                            input_db->getDatabase("GriddingAlgorithm"),
                            error_detector,
                            box_generator,
                            load_balancer);

   /*
    * Build an initial grid hierarchy.  Note that in this simple
    * example we do not buffer the refinement regions.
    */
   gridding_algorithm->makeCoarsestLevel(hierarchy, 0.0);
   
   bool done = false;
   bool initial_time = true;
   for (int ln = 0;
        gridding_algorithm->levelCanBeRefined(ln) && !done; 
        ln++) {
       gridding_algorithm->makeFinerLevel(hierarchy,
                                          0.0,
                                          initial_time,
                                          0);
       done = !(hierarchy->finerLevelExists(ln));
   }
}

