! The header for the binary checkpoint files.
! This needs to go in its own module for some reason, because otherwise 
! some compilers won't like the INTERFACE block needed to allow us to 
! use the PetscBagGetData() routine.
! RTM: This is pretty makeshift.  We need to think about what should 
! go into this header and how it should be organized.

! MUST INCREMENT THIS NUMBER EVERYTIME A CHECKPOINT FILE IS MODIFIED TO PREVENT
! COMPATIBILITY ISSUES - geh.
#define REVISION_NUMBER 1

module Checkpoint_Header_module
  implicit none
  private
  type, public :: checkpoint_header_type
    integer*8 :: revision_number  ! increment this every time there is a change
                                             ! in the checkpoint file format
    real*8 :: flow_time
    real*8 :: flow_dt
    integer*8 :: flow_steps
    integer*8 :: flow_newtcum
    integer*8 :: flow_icutcum
    integer*8 :: flow_linear_cum
    integer*8 :: flow_num_const_timesteps
    integer*8 :: flow_num_newton_iterations
    real*8 :: flow_cumulative_solver_time  ! don't implement yet; will screw up restarts
    real*8 :: tran_time
    real*8 :: tran_dt
    integer*8 :: tran_steps
    integer*8 :: tran_newtcum
    integer*8 :: tran_icutcum
    integer*8 :: tran_linear_cum
    integer*8 :: tran_num_const_timesteps
    integer*8 :: tran_num_newton_iterations
    real*8 :: tran_cumulative_solver_time  ! don't implement yet; will screw up restarts
    integer*8 :: plot_number
    integer*8 :: nflowdof
    integer*8 :: ntrandof
    integer*8 :: checkpoint_activity_coefs
  end type checkpoint_header_type
end module Checkpoint_Header_module

module Checkpoint_module

  use Checkpoint_Header_module

  implicit none
  
  private

  public :: Checkpoint, Restart

#include "definitions.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscda.h"
#include "finclude/petscda.h90"
#include "finclude/petscdef.h"
#include "finclude/petscis.h"
#include "finclude/petscis.h90"
#include "finclude/petsclog.h"
#include "finclude/petscsys.h"
#include "finclude/petscviewer.h"
#include "finclude/petscbag.h"

  Interface PetscBagGetData
    Subroutine PetscBagGetData(bag,ctx,ierr)
      use Checkpoint_Header_module
      PetscBag bag
      type(checkpoint_header_type), pointer :: ctx
      PetscErrorCode ierr
    End Subroutine
  End Interface PetscBagGetData

contains

subroutine Checkpoint(realization, &
                      flow_steps,flow_newtcum,flow_icutcum, &
                      flow_linear_cum, &
                      flow_num_const_timesteps, &
                      flow_num_newton_iterations, &
                      flow_cumulative_solver_time, &
                      tran_steps,tran_newtcum,tran_icutcum, &
                      tran_linear_cum, &
                      tran_num_const_timesteps, &
                      tran_num_newton_iterations, &
                      tran_cumulative_solver_time, &
                      id)

  use Realization_module
  use Reaction_Aux_module
  use Discretization_module
  use Option_module
  use Field_module
  use Logging_module
  
  use MPHASE_module
  use Immis_module

  use Reactive_Transport_module, only : RTCheckpointKineticSorption

  implicit none

  type(realization_type) :: realization
  PetscInt :: flow_num_const_timesteps
  PetscInt :: flow_num_newton_iterations
  PetscInt :: flow_steps, flow_newtcum, flow_icutcum, flow_linear_cum
  PetscReal :: flow_cumulative_solver_time
  PetscInt :: tran_num_const_timesteps
  PetscInt :: tran_num_newton_iterations
  PetscInt :: tran_steps, tran_newtcum, tran_icutcum, tran_linear_cum
  PetscReal :: tran_cumulative_solver_time
  PetscInt, intent(in) :: id  ! id should not be altered within this subroutine
  PetscInt :: checkpoint_activity_coefs
#ifdef PetscSizeT
  PetscSizeT :: bagsize
#else
  ! PETSC_SIZEOF_SIZE_T isn't defined, so we just have to assume that it 
  ! is 8 bytes.  This is dangerous, but what can we do?
  integer*8 :: bagsize
#endif

  character(len=MAXSTRINGLENGTH) :: filename
  character(len=MAXWORDLENGTH) :: id_string
  PetscViewer :: viewer
  PetscBag :: bag
  type(checkpoint_header_type), pointer :: header
  PetscErrorCode :: ierr
  PetscLogDouble :: tstart, tend  
  
  Vec :: global_vec = 0
  PetscInt :: int_flag
  
  type(field_type), pointer :: field
  type(option_type), pointer :: option
  type(discretization_type), pointer :: discretization
  type(output_option_type), pointer :: output_option
  PetscInt :: i

  call PetscLogStagePush(logging%stage(OUTPUT_STAGE),ierr)
  call PetscLogEventBegin(logging%event_checkpoint, &
                          PETSC_NULL_OBJECT,PETSC_NULL_OBJECT, &
                          PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,ierr)  
    
  field => realization%field
  option => realization%option
  discretization => realization%discretization
  output_option => realization%output_option

  ! Open the checkpoint file.
  call PetscGetTime(tstart,ierr)   
  if (id < 0) then
    filename = 'restart' // trim(option%group_prefix) // '.chk'
  else 
    write(id_string,'(i8)') id
    filename = trim(option%global_prefix) // trim(option%group_prefix) // &
               '.chk' // trim(adjustl(id_string))
  endif
  call PetscViewerBinaryOpen(option%mycomm, filename, FILE_MODE_WRITE, &
                             viewer, ierr)

  !--------------------------------------------------------------------
  ! Dump some important information such as simulation time, 
  ! time step size, etc.
  !--------------------------------------------------------------------

  ! We manually specify the number of bytes required for the 
  ! checkpoint header, since sizeof() is not supported by some Fortran 
  ! compilers.  To be on the safe side, we assume an integer is 8 bytes.
  bagsize = 184
  call PetscBagCreate(option%mycomm, bagsize, bag, ierr)
  call PetscBagGetData(bag, header, ierr); CHKERRQ(ierr)

  i = REVISION_NUMBER
  call PetscBagRegisterInt(bag,header%revision_number,i, &
                           "revision_number","revision_number",ierr)

  ! Register variables that are passed into timestepper().
  call PetscBagRegisterInt(bag,header%plot_number,output_option%plot_number, &
                           "plot_number","plot_number",ierr)
  ! FLOW
  call PetscBagRegisterInt(bag,header%nflowdof,option%nflowdof, &
                           "nflowdof","Number of flow degrees of freedom",ierr)
  call PetscBagRegisterInt(bag,header%flow_num_newton_iterations, &
                           flow_num_newton_iterations, &
                           "flow_num_newton_iterations", &
                           "Number of flow Newton iterations in last SNES solve", &
                           ierr)
  call PetscBagRegisterInt(bag,header%flow_num_const_timesteps, &
                           flow_num_const_timesteps, &
                           "flow_num_const_timesteps", &
                           "flow_num_const_timesteps",ierr)

  ! TRANSPORT
  call PetscBagRegisterInt(bag,header%tran_num_newton_iterations, &
                           tran_num_newton_iterations, &
                           "tran_num_newton_iterations", &
                           "Number of transport Newton iterations in last SNES solve", &
                           ierr)
  call PetscBagRegisterInt(bag,header%tran_num_const_timesteps, &
                           tran_num_const_timesteps, &
                           "tran_num_const_timesteps", &
                           "tran_num_const_timesteps",ierr)
  
  ! Register relevant components of the stepper.
  ! FLOW
  call PetscBagRegisterReal(bag,header%flow_time,option%flow_time,"flow_time", &
                            "Flow Simulation time (seconds)",ierr)
  call PetscBagRegisterReal(bag,header%flow_dt,option%flow_dt,"flow_dt", &
                            "Current size of flow timestep (seconds)",ierr)
  call PetscBagRegisterInt(bag,header%flow_steps,flow_steps,"flow_steps", &
                            "Total number of flow steps taken",ierr)
  call PetscBagRegisterInt(bag,header%flow_newtcum,flow_newtcum,"flow_newtcum", &
                            "Total number of flow Newton steps taken",ierr)
  call PetscBagRegisterInt(bag,header%flow_icutcum,flow_icutcum,"flow_icutcum", &
                            "Total number of flow time step cuts",ierr)
  call PetscBagRegisterInt(bag,header%flow_linear_cum,flow_linear_cum,"flow_linear_cum", &
                            "Total number of flow linear iterations",ierr)
  call PetscBagRegisterReal(bag,header%flow_cumulative_solver_time, &
                            flow_cumulative_solver_time, &
                            "flow_cumulative_solver_time", &
                            "flow_cumulative_solver_time",ierr)
                                                        
  ! TRANSPORT
  call PetscBagRegisterInt(bag,header%ntrandof,option%ntrandof, &
                           "ntrandof", &
                           "Number of transport degrees of freedom",ierr)
  call PetscBagRegisterReal(bag,header%tran_time,option%tran_time,"tran_time", &
                            "Transport Simulation time (seconds)",ierr)
  call PetscBagRegisterReal(bag,header%tran_dt,option%tran_dt,"tran_dt", &
                            "Current size of transport timestep (years)",ierr)
                            
  call PetscBagRegisterInt(bag,header%tran_steps,tran_steps,"tran_steps", &
                            "Total number of transport steps taken",ierr)
  call PetscBagRegisterInt(bag,header%tran_newtcum,tran_newtcum,"tran_newtcum", &
                            "Total number of transport Newton steps taken",ierr)
  call PetscBagRegisterInt(bag,header%tran_icutcum,tran_icutcum,"tran_icutcum", &
                            "Total number of transport time step cuts",ierr)
  call PetscBagRegisterInt(bag,header%tran_linear_cum,tran_linear_cum,"tran_linear_cum", &
                            "Total number of transport linear iterations",ierr)
  call PetscBagRegisterReal(bag,header%tran_cumulative_solver_time, &
                            tran_cumulative_solver_time, &
                            "tran_cumulative_solver_time", &
                            "tran_cumulative_solver_time",ierr)

  if (associated(realization%reaction)) then
    if (realization%reaction%checkpoint_activity_coefs .and. &
        realization%reaction%act_coef_update_frequency /= &
        ACT_COEF_FREQUENCY_OFF) then
      checkpoint_activity_coefs = ONE_INTEGER
    else
      checkpoint_activity_coefs = ZERO_INTEGER
    endif
  else
    checkpoint_activity_coefs = ZERO_INTEGER
  endif
  call PetscBagRegisterInt(bag,header%checkpoint_activity_coefs, &
                           checkpoint_activity_coefs, &
                           "checkpoint_activity_coefs", &
                            "Flag indicating whether activity coefficients were checkpointed",ierr)                            

  ! Actually write the components of the PetscBag and then free it.
  call PetscBagView(bag, viewer, ierr)
  call PetscBagDestroy(bag, ierr)

  !--------------------------------------------------------------------
  ! Dump all the relevant vectors.
  !--------------------------------------------------------------------

  if (option%nflowdof > 0) then
    call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                    global_vec,GLOBAL,option)
    ! grid%flow_xx is the vector into which all of the primary variables are 
    ! packed for the SNESSolve().
    call VecView(field%flow_xx, viewer, ierr)

    ! If we are running with multiple phases, we need to dump the vector 
    ! that indicates what phases are present, as well as the 'var' vector 
    ! that holds variables derived from the primary ones via the translator.
    select case(option%iflowmode)
      case(MPH_MODE,THC_MODE,RICHARDS_MODE, IMS_MODE)
        call DiscretizationLocalToGlobal(realization%discretization, &
                                         field%iphas_loc,global_vec,ONEDOF)
        call VecView(global_vec, viewer, ierr)
       case default
    end select 

    ! Porosity and permeability.
    ! (We only write diagonal terms of the permeability tensor for now, 
    ! since we have yet to add the full-tensor formulation.)
    call DiscretizationLocalToGlobal(discretization,field%porosity_loc, &
                                     global_vec,ONEDOF)
    call VecView(global_vec,viewer,ierr)
    call DiscretizationLocalToGlobal(discretization,field%perm_xx_loc, &
                                     global_vec,ONEDOF)
    call VecView(global_vec,viewer,ierr)
    call DiscretizationLocalToGlobal(discretization,field%perm_yy_loc, &
                                     global_vec,ONEDOF)
    call VecView(global_vec,viewer,ierr)
    call DiscretizationLocalToGlobal(discretization,field%perm_zz_loc, &
                                     global_vec,ONEDOF)
    call VecView(global_vec,viewer,ierr)

  endif

  if (option%ntrandof > 0) then
    call VecView(field%tran_xx, viewer, ierr)
    if (realization%reaction%checkpoint_activity_coefs .and. &
        realization%reaction%act_coef_update_frequency /= &
        ACT_COEF_FREQUENCY_OFF) then
      ! allocated vector
      if (global_vec == 0) then
        call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                        global_vec,GLOBAL,option)
      endif
      do i = 1, realization%reaction%ncomp
        call RealizationGetDataset(realization,global_vec, &
                                   PRIMARY_ACTIVITY_COEF,i)
        call VecView(global_vec,viewer,ierr)
      enddo
      do i = 1, realization%reaction%neqcplx
        call RealizationGetDataset(realization,global_vec, &
                                   SECONDARY_ACTIVITY_COEF,i)
        call VecView(global_vec,viewer,ierr)
      enddo
    endif
    if (realization%reaction%kinmr_nrate > 0 .and. &
        .not.option%no_checkpoint_kinetic_sorption) then
      ! PETSC_TRUE flag indicates write to file
      call RTCheckpointKineticSorption(realization,viewer,PETSC_TRUE)
    endif
  endif

  if (global_vec /= 0) then
    call VecDestroy(global_vec,ierr)
  endif
 
  ! We are finished, so clean up.
  call PetscViewerDestroy(viewer, ierr)

  write(option%io_buffer,'(" --> Dump checkpoint file: ", a16)') trim(filename)
  call printMsg(option)

  call PetscGetTime(tend,ierr) 
  write(option%io_buffer, &
        '("      Seconds to write to checkpoint file: ", f6.2)') tend-tstart
  call printMsg(option)

  call PetscLogEventEnd(logging%event_checkpoint, &
                        PETSC_NULL_OBJECT,PETSC_NULL_OBJECT, &
                        PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,ierr)  
  call PetscLogStagePop(ierr)

end subroutine Checkpoint

subroutine Restart(realization, &
                   flow_steps,flow_newtcum,flow_icutcum, &
                   flow_linear_cum, &
                   flow_num_const_timesteps, &
                   flow_num_newton_iterations, &
                   flow_cumulative_solver_time, &
                   tran_steps,tran_newtcum,tran_icutcum, &
                   tran_linear_cum, &
                   tran_num_const_timesteps, &
                   tran_num_newton_iterations, &
                   tran_cumulative_solver_time, &
                   flow_read, &
                   transport_read, &
                   activity_coefs_read)

  use Realization_module
  use Discretization_module
  use Option_module
  use Field_module
  use Logging_module

  use MPHASE_module
  use Immis_module
  
  use Reactive_Transport_module, only: RTCheckpointKineticSorption

  implicit none

  type(realization_type) :: realization
  PetscInt :: flow_num_const_timesteps
  PetscInt :: flow_num_newton_iterations
  PetscInt :: flow_steps, flow_newtcum, flow_icutcum, flow_linear_cum
  PetscReal :: flow_cumulative_solver_time
  PetscInt :: tran_num_const_timesteps
  PetscInt :: tran_num_newton_iterations
  PetscInt :: tran_steps, tran_newtcum, tran_icutcum, tran_linear_cum
  PetscReal :: tran_cumulative_solver_time
  PetscTruth :: activity_coefs_read, flow_read, transport_read

  PetscViewer viewer
  PetscBag bag
  type(checkpoint_header_type), pointer :: header
  PetscErrorCode :: ierr
  PetscLogDouble :: tstart, tend

  Vec :: global_vec = 0
  Vec :: local_vec = 0
  PetscInt :: int_flag
  PetscInt :: i
  PetscInt :: read_activity_coefs
  character(len=MAXSTRINGLENGTH) :: string
  
  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization
  type(option_type), pointer :: option
  type(output_option_type), pointer :: output_option

  call PetscLogEventBegin(logging%event_restart, &
                          PETSC_NULL_OBJECT,PETSC_NULL_OBJECT, &
                          PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,ierr)  
  
  field => realization%field
  option => realization%option
  discretization => realization%discretization
  output_option => realization%output_option
  
  call PetscGetTime(tstart,ierr)
  option%io_buffer = '--> Open checkpoint file: ' // &
                     trim(option%restart_filename)
  call printMsg(option)
  call PetscViewerBinaryOpen(option%mycomm,option%restart_filename, &
                             FILE_MODE_READ,viewer,ierr)
 
  activity_coefs_read = PETSC_FALSE
  
  ! Get the header data.
  call PetscBagLoad(viewer, bag, ierr)
  call PetscBagGetData(bag, header, ierr)
  
  if (header%revision_number /= REVISION_NUMBER) then
    write(string,*) header%revision_number
    option%io_buffer = 'The revision number # of checkpoint file (' // &
                       trim(option%restart_filename) // ', rev=' // &
                       trim(adjustl(string)) // &
                       ') does not match the current revision number' // &
                       ' of PFLOTRAN checkpoint files ('
    write(string,*) REVISION_NUMBER
    option%io_buffer = trim(option%io_buffer) // trim(adjustl(string)) // ').'
    call printErrMsg(option)
  endif
  
  output_option%plot_number = header%plot_number
  ! FLOW
  if (option%nflowdof > 0 .and. option%nflowdof == header%nflowdof) then
    option%flow_time = header%flow_time
    option%flow_dt = header%flow_dt
    flow_num_newton_iterations = header%flow_num_newton_iterations
    flow_num_const_timesteps = header%flow_num_const_timesteps
    flow_steps = header%flow_steps
    flow_newtcum = header%flow_newtcum
    flow_icutcum = header%flow_icutcum
    flow_linear_cum = header%flow_linear_cum
    flow_cumulative_solver_time = header%flow_cumulative_solver_time
    flow_cumulative_solver_time = 0.d0
    flow_read = PETSC_TRUE
  endif
  ! TRANSPORT
  if (option%ntrandof > 0.and. option%ntrandof == header%ntrandof) then
    option%tran_time = header%tran_time
    option%tran_dt = header%tran_dt
    tran_num_newton_iterations = header%tran_num_newton_iterations
    tran_num_const_timesteps = header%tran_num_const_timesteps
    tran_steps = header%tran_steps
    tran_newtcum = header%tran_newtcum
    tran_icutcum = header%tran_icutcum
    tran_linear_cum = header%tran_linear_cum
    tran_cumulative_solver_time = header%tran_cumulative_solver_time
    tran_cumulative_solver_time = 0.d0
    read_activity_coefs = header%checkpoint_activity_coefs
    transport_read = PETSC_TRUE
  else
    write(string,*) header%ntrandof
    option%io_buffer = 'Number of transport dofs in restart file (' // &
                       trim(adjustl(string)) // &
           ') does not match the number of transport dofs in the input file ('
    write(string,*) option%ntrandof
    option%io_buffer = trim(option%io_buffer) // string // ')'
    call printWrnMsg(option)
  endif

  if (flow_read) then
    call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                    global_vec,GLOBAL,option)
  ! Load the PETSc vectors.
    call VecLoadIntoVector(viewer,field%flow_xx,ierr)
    call DiscretizationGlobalToLocal(discretization,field%flow_xx, &
                                     field%flow_xx_loc,NFLOWDOF)
    call VecCopy(field%flow_xx,field%flow_yy,ierr)
    
    select case(option%iflowmode)
      case(MPH_MODE,THC_MODE,RICHARDS_MODE, IMS_MODE)
        call VecLoadIntoVector(viewer, global_vec, ierr)      
        call DiscretizationGlobalToLocal(discretization,global_vec, &
                                         field%iphas_loc,ONEDOF)
        call VecCopy(field%iphas_loc,field%iphas_old_loc,ierr)
        call DiscretizationLocalToLocal(discretization,field%iphas_loc, &
                                        field%iphas_old_loc,ONEDOF)
        if (option%iflowmode == MPH_MODE) then
        ! set vardof vec in mphase
        endif
        if (option%iflowmode == IMS_MODE) then
        ! set vardof vec in mphase
        endif

      case default
    end select
    
    call VecLoadIntoVector(viewer, global_vec, ierr)
    call DiscretizationGlobalToLocal(discretization,global_vec, &
                                     field%porosity_loc,ONEDOF)
    call VecLoadIntoVector(viewer,global_vec,ierr)
    call DiscretizationGlobalToLocal(discretization,global_vec, &
                                     field%perm_xx_loc,ONEDOF)
    call VecLoadIntoVector(viewer,global_vec,ierr)
    call DiscretizationGlobalToLocal(discretization,global_vec, &
                                     field%perm_yy_loc,ONEDOF)
    call VecLoadIntoVector(viewer,global_vec,ierr)
    call DiscretizationGlobalToLocal(discretization,global_vec, &
                                     field%perm_zz_loc,ONEDOF)
    
  endif
  
  if (transport_read) then
    call VecLoadIntoVector(viewer,field%tran_xx,ierr)
    call DiscretizationGlobalToLocal(discretization,field%tran_xx, &
                                     field%tran_xx_loc,NTRANDOF)
    call VecCopy(field%tran_xx,field%tran_yy,ierr)

    if (read_activity_coefs == ONE_INTEGER) then
      activity_coefs_read = PETSC_TRUE
      if (global_vec == 0) then
        call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                        global_vec,GLOBAL,option)
      endif    
      call DiscretizationCreateVector(discretization,ONEDOF,local_vec, &
                                      LOCAL,option)
      do i = 1, realization%reaction%ncomp
        call VecLoadIntoVector(viewer,global_vec,ierr)
        call DiscretizationGlobalToLocal(discretization,global_vec, &
                                         local_vec,ONEDOF)
        call RealizationSetDataset(realization,local_vec,LOCAL, &
                                   PRIMARY_ACTIVITY_COEF,i)
      enddo
      do i = 1, realization%reaction%neqcplx
        call VecLoadIntoVector(viewer,global_vec,ierr)
        call DiscretizationGlobalToLocal(discretization,global_vec, &
                                         local_vec,ONEDOF)
        call RealizationSetDataset(realization,local_vec,LOCAL, &
                                   SECONDARY_ACTIVITY_COEF,i)
      enddo
      if (realization%reaction%kinmr_nrate > 0 .and. &
          .not.option%no_restart_kinetic_sorption) then
        ! PETSC_FALSE flag indicates read from file
        call RTCheckpointKineticSorption(realization,viewer,PETSC_FALSE)
      endif
      call VecDestroy(local_vec,ierr)
    endif
  endif
    
  ! We are finished, so clean up.
  if (global_vec /= 0) then
    call VecDestroy(global_vec,ierr)
  endif
  call PetscViewerDestroy(viewer, ierr)
  call PetscGetTime(tend,ierr) 

  call PetscBagDestroy(bag, ierr)

  write(option%io_buffer, &
        '("      Seconds to read to checkpoint file: ", f6.2)') tend-tstart
  call printMsg(option)

  call PetscLogEventEnd(logging%event_restart, &
                        PETSC_NULL_OBJECT,PETSC_NULL_OBJECT, &
                        PETSC_NULL_OBJECT,PETSC_NULL_OBJECT,ierr)  
  
end subroutine Restart

end module Checkpoint_module
