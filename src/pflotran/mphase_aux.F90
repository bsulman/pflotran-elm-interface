module Mphase_Aux_module
use mphase_pckr_module

  implicit none
  
  private 
!#define GARCIA 1
#define DUANDEN 1
#include "definitions.h"

type, public :: mphase_auxvar_elem_type
   PetscReal :: pres
    PetscReal :: temp
    PetscReal , pointer :: sat(:)
    PetscReal , pointer :: den(:)
    PetscReal , pointer :: avgmw(:)
    PetscReal , pointer :: vis(:)
    PetscReal , pointer :: h(:)
    PetscReal , pointer :: u(:)
    PetscReal , pointer :: pc(:)
    PetscReal , pointer :: kvr(:)
    PetscReal , pointer :: xmol(:)
    PetscReal , pointer :: diff(:)
    PetscReal , pointer :: hysdat(:)
    PetscReal :: zco2
!    PetscReal :: dvis_dp
!    PetscReal :: kr
!    PetscReal :: dkr_dp
 end type mphase_auxvar_elem_type

  type, public :: mphase_auxvar_type
    
    type(mphase_auxvar_elem_type), pointer :: aux_var_elem(:) 
#if 0
    PetscReal , pointer :: davgmw_dx(:)
    PetscReal , pointer :: dden_dp(:)
    PetscReal , pointer :: dden_dt(:)
    PetscReal , pointer :: dden_dx(:)
    PetscReal , pointer :: dkvr_dp(:)
    PetscReal , pointer :: dkvr_dt(:)
    PetscReal , pointer :: dkvr_ds(:)
    PetscReal , pointer :: dkvr_dx(:)
    PetscReal , pointer :: dh_dp(:)
    PetscReal , pointer :: dh_dt(:)
    PetscReal , pointer :: dh_dx(:)
    PetscReal , pointer :: du_dp(:)
    PetscReal , pointer :: du_dt(:)
    PetscReal , pointer :: du_dx(:)
#endif
  end type mphase_auxvar_type
  
  type, public :: mphase_parameter_type
    PetscReal, pointer :: dencpr(:)
    PetscReal, pointer :: ckwet(:)
    PetscReal, pointer :: sir(:,:)
  end type mphase_parameter_type
  
  type, public :: mphase_type
     PetscInt :: n_zero_rows
     PetscInt, pointer :: zero_rows_local(:), zero_rows_local_ghosted(:)

     PetscBool :: aux_vars_up_to_date
     PetscBool :: inactive_cells_exist
     PetscInt :: num_aux, num_aux_bc, num_aux_ss

     PetscReal, pointer :: res_old_AR(:,:)
     PetscReal, pointer :: res_old_FL(:,:)
     PetscReal, pointer :: delx(:,:)
  
     type(mphase_parameter_type), pointer :: mphase_parameter
     type(mphase_auxvar_type), pointer :: aux_vars(:)
     type(mphase_auxvar_type), pointer :: aux_vars_bc(:)
     type(mphase_auxvar_type), pointer :: aux_vars_ss(:)
#ifdef MC_HEAT
     type(sec_heat_type), pointer :: sec_heat_vars(:)
#endif
  end type mphase_type

#ifdef MC_HEAT  
  type, public :: sec_heat_type  ! now assuming only 1D secondary continuum
    PetscBool :: sec_temp_update
    PetscInt :: ncells
    PetscReal :: length
    PetscReal :: area
    PetscReal :: vol
    PetscReal :: interfacial_area
    PetscReal :: grid_size
    PetscReal :: epsilon
    PetscReal, pointer :: sec_temp(:)
  end type sec_heat_type  
#endif

  public :: MphaseAuxCreate, MphaseAuxDestroy, &
            MphaseAuxVarCompute_NINC, MphaseAuxVarCompute_WINC, &
#ifdef MC_HEAT
            MphaseSecHeatAuxVarCompute, &
#endif            
            MphaseAuxVarInit, MphaseAuxVarCopy

contains
 


! ************************************************************************** !
!
! MphaseAuxVarCreate: Allocate and initialize auxilliary object
! author: Chuan Lu
! date: 
!
! ************************************************************************** !
function MphaseAuxCreate()

  use Option_module

  implicit none
  
  type(mphase_type), pointer :: MphaseAuxCreate
  
  type(mphase_type), pointer :: aux

  allocate(aux) 
  aux%aux_vars_up_to_date = PETSC_FALSE
  aux%inactive_cells_exist = PETSC_FALSE
  aux%num_aux = 0
  aux%num_aux_bc = 0
  aux%num_aux_ss = 0
  nullify(aux%aux_vars)
  nullify(aux%aux_vars_bc)
  nullify(aux%aux_vars_ss)
  aux%n_zero_rows = 0
  allocate(aux%mphase_parameter)
  nullify(aux%mphase_parameter%sir)
  nullify(aux%mphase_parameter%ckwet)
  nullify(aux%mphase_parameter%dencpr)
  nullify(aux%zero_rows_local)
  nullify(aux%zero_rows_local_ghosted)
  nullify(aux%res_old_AR)
  nullify(aux%res_old_FL)
  nullify(aux%delx)
  
#ifdef MC_HEAT  
  nullify(aux%sec_heat_vars)
#endif

  MphaseAuxCreate => aux
  
end function MphaseAuxCreate



! ************************************************************************** !
!
! MphaseAuxVarInit: Initialize auxilliary object
! author: Chuan Lu
! date: 
!
! ************************************************************************** !
subroutine MphaseAuxVarInit(aux_var,option)

  use Option_module

  implicit none
  
  type(mphase_auxvar_type) :: aux_var
  type(option_type) :: option

  PetscInt :: var_elem_size, var_node_size
  PetscInt :: nvar 

  allocate(aux_var%aux_var_elem(0 : option%nflowdof))
  allocate(aux_var%aux_var_elem(0)%hysdat(4))
 
  do nvar = 0, option%nflowdof
     allocate ( aux_var%aux_var_elem(nvar)%sat(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%den(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%avgmw(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%h(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%u(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%pc(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%kvr(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%vis(option%nphase))
     allocate ( aux_var%aux_var_elem(nvar)%xmol(option%nphase*option%nflowspec))
     allocate ( aux_var%aux_var_elem(nvar)%diff(option%nphase*option%nflowspec))
     if(nvar>0) &
       aux_var%aux_var_elem(nvar)%hysdat => aux_var%aux_var_elem(0)%hysdat

     aux_var%aux_var_elem(nvar)%pres = 0.d0
     aux_var%aux_var_elem(nvar)%temp = 0.d0
     aux_var%aux_var_elem(nvar)%sat = 0.d0
     aux_var%aux_var_elem(nvar)%den = 0.d0
     aux_var%aux_var_elem(nvar)%avgmw = 0.d0
     aux_var%aux_var_elem(nvar)%h = 0.d0
     aux_var%aux_var_elem(nvar)%u = 0.d0
     aux_var%aux_var_elem(nvar)%pc = 0.d0
     aux_var%aux_var_elem(nvar)%kvr = 0.d0
     aux_var%aux_var_elem(nvar)%xmol = 0.d0
     aux_var%aux_var_elem(nvar)%diff = 0.d0
     aux_var%aux_var_elem(nvar)%vis = 0.d0
#if 0
     aux_var%aux_var_elem(nvar)%dsat_dp = 0.d0
     aux_var%aux_var_elem(nvar)%dden_dp = 0.d0
     aux_var%aux_var_elem(nvar)%dkvr_dp = 0.d0
#endif
  enddo

end subroutine MphaseAuxVarInit

! ************************************************************************** !
!
! THCAuxVarCopy: Copies an auxilliary variable
! author: 
! date: 
!
! ************************************************************************** !  
subroutine MphaseAuxVarCopy(aux_var,aux_var2,option)

  use Option_module

  implicit none
  
  type(mphase_auxvar_elem_type) :: aux_var, aux_var2
  type(option_type) :: option

  aux_var2%pres = aux_var%pres
  aux_var2%temp = aux_var%temp
  aux_var2%sat = aux_var%sat
  aux_var2%den = aux_var%den
  aux_var2%avgmw = aux_var%avgmw
  aux_var2%h = aux_var%h
  aux_var2%u = aux_var%u
  aux_var2%pc = aux_var%pc
!  aux_var2%kr = aux_var%kr
!  aux_var2%dkr_dp = aux_var%dkr_dp
  aux_var2%vis = aux_var%vis
!  aux_var2%dvis_dp = aux_var%dvis_dp
  aux_var2%kvr = aux_var%kvr
#if 0
  aux_var2%dsat_dp = aux_var%dsat_dp
  aux_var2%dden_dp = aux_var%dden_dp
  aux_var2%dden_dt = aux_var%dden_dt
  aux_var2%dkvr_dp = aux_var%dkvr_dp
  aux_var2%dkvr_dt = aux_var%dkvr_dt
  aux_var2%dh_dp = aux_var%dh_dp
  aux_var2%dh_dt = aux_var%dh_dt
  aux_var2%du_dp = aux_var%du_dp
  aux_var2%du_dt = aux_var%du_dt  
#endif
  aux_var2%xmol = aux_var%xmol
  aux_var2%diff = aux_var%diff

end subroutine MphaseAuxVarCopy


! ************************************************************************** !
!
! MphaseAuxVarCompute_NI: Computes auxilliary variables for each grid cell
!                        No increments 
! author: Chuan Lu
! date: 
!
! ************************************************************************** !
subroutine MphaseAuxVarCompute_NINC(x,aux_var,global_aux_var,iphase,saturation_function, &
                                   fluid_properties,option,xphico2)

  use Option_module
  use Global_Aux_module
  use water_eos_module
  use gas_eos_module
  use co2eos_module
  use span_wagner_module
  use span_wagner_spline_module, only: sw_prop
  use co2_sw_module, only: co2_sw_interp
  use Saturation_Function_module
  use Fluid_module
  use mphase_pckr_module
  
  implicit none

  type(option_type) :: option
  type(fluid_property_type) :: fluid_properties
  type(saturation_function_type) :: saturation_function
  PetscReal :: x(option%nflowdof)
  type(mphase_auxvar_elem_type) :: aux_var
  type(global_auxvar_type) :: global_aux_var
  PetscInt :: iphase
  PetscReal, optional :: xphico2

  PetscErrorCode :: ierr
  PetscReal :: pw, dw_kg, dw_mol, hw, sat_pressure, visl
  PetscReal :: p, t, temp, p2, err
  PetscReal :: henry, lngamco2
  PetscReal :: dg, dddp, dddt, m_na, m_cl, m_nacl
  PetscReal :: fg, dfgdp, dfgdt, xphi
  PetscReal :: eng, hg, dhdp, dhdt
  PetscReal :: visg, dvdp, dvdt
  PetscReal :: h(option%nphase), u(option%nphase), kr(option%nphase)
  PetscReal :: xm_nacl, y_nacl, vphi             
  PetscReal :: tk, xco2, pw_kg, x1, vphi_a1, vphi_a2 
  PetscReal :: Qkco2, mco2, xco2eq
  PetscInt :: iflag
  
  aux_var%den = 0.d0
  aux_var%sat = 0.d0
  
  aux_var%h = 0.d0
  aux_var%u = 0.d0
  aux_var%avgmw = 0.d0
  aux_var%xmol = 0.d0
  aux_var%pc = 0.d0
  aux_var%kvr = 0.d0
  aux_var%diff = 0.d0
  kr = 0.d0
 
  aux_var%pres = x(1)  
  aux_var%temp = x(2)

  p = aux_var%pres
  t = aux_var%temp
  
  select case(iphase)
!******* Only aqueous phase exist ***********  
    case(1)
      aux_var%xmol(2) = x(3)
!      if(aux_var%xmol(2) < 0.D0) print *,'tran:',iphase, x(1:3)
!      if(aux_var%xmol(2) > 1.D0) print *,'tran:',iphase, x(1:3)
      aux_var%xmol(1) = 1.D0 - aux_var%xmol(2)
      aux_var%pc(:) = 0.D0
      aux_var%sat(1) = 1.D0
      aux_var%sat(2) = 0.D0
      kr(1)= 1.D0
      kr(2)= 0.D0
!******* Only gas phase exist ***********  
    case(2)
      aux_var%xmol(4)=x(3)
!      if(aux_var%xmol(4) < 0.D0) print *,'tran:',iphase, x(1:3)
!      if(aux_var%xmol(4) > 1.D0) print *,'tran:',iphase, x(1:3)
      aux_var%xmol(3) = 1.D0 - aux_var%xmol(4)
      aux_var%pc(:) = 0.D0
      aux_var%sat(1) = 0.D0
      aux_var%sat(2) = 1.D0
      aux_var%pc(2) = 0.D0
      kr(1)= 0.D0
      kr(2)= 1.D0
    case(3)    
      aux_var%sat(2) = x(3)
      if(aux_var%sat(2) < 0.D0)then
!        print *,'tran:',iphase, x(1:3)
        aux_var%sat(2) = 0.D0
      endif
!      if(aux_var%sat(2)> 1.D0) print *,'tran:',iphase, x(1:3)
      aux_var%sat(1) = 1.D0 - aux_var%sat(2)
      aux_var%pc(:) = 0.D0
      temp = 1D-2
      aux_var%xmol(1)=1.D0; aux_var%xmol(2)=0.D0
      aux_var%xmol(3)=temp; aux_var%xmol(4)=1.D0-aux_var%xmol(3)
   end select
! ********************* Gas phase properties ***********************
    call PSAT(t, sat_pressure, ierr)
    err = 1.D0
    p2 = p

    if (p2 >= 5.d4) then
       
      if (option%co2eos == EOS_SPAN_WAGNER) then
! ************ Span-Wagner EOS ********************             
        select case(option%itable)  
          case(0,1,2,4,5)
            if (option%itable >= 4) then
                ! print *,' interp', itable
              call co2_sw_interp(p2*1.D-6,t,dg,dddt,dddp,fg, &
                     dfgdp,dfgdt,eng,hg,dhdt,dhdp,visg,dvdt,dvdp,option%itable)
            else
              iflag = 1
              call co2_span_wagner(p2*1.D-6,t+273.15D0,dg,dddt,dddp,fg, &
                     dfgdp,dfgdt,eng,hg,dhdt,dhdp,visg,dvdt,dvdp,iflag, &
                     option%itable)
            endif

            dg = dg/FMWCO2
            fg = fg*1.D6 
            hg = hg*FMWCO2
            xphi = fg/p2
            
! ************* Span-Wagner EOS with Bi-Cubic Spline interpolation ********
          case(3) 
            call sw_prop(t,p2*1.D-6,dg,hg,eng,fg)
            call visco2(t,dg,visg)
            dg = dg/FMWCO2
            fg = fg*1.D6 
            hg = hg*FMWCO2
            xphi = fg/p2
          end select
          
       elseif (option%co2eos == EOS_MRK) then
       
! MRK eos [modified version from  Kerrick and Jacobs (1981) and Weir et al. (1996).]     
          call CO2(t,p2,dg,fg,xphi,hg)
          call visco2(t,dg,visg)
          dg = dg/FMWCO2
          hg = hg*FMWCO2*option%scale
          !      print *, 'translator', p2,t,dg,hg,visg
       else
         call printErrMsg(option,'pflow mphase ERROR: Need specify CO2 EOS')
      endif
    else      
      call ideal_gaseos_noderiv(p2,t,option%scale,dg,hg,eng)
      call visco2(t,dg*FMWCO2,visg)
      fg = p2
      xphi = 1.D0
    endif

    m_na=option%m_nacl; m_cl=m_na; m_nacl=m_na 
    if (option%ntrandof > 0) then
      m_na = global_aux_var%m_nacl(1)
      m_cl = global_aux_var%m_nacl(2)
      m_nacl = m_na
      if (m_cl > m_na) m_nacl = m_cl
    endif  


    call Henry_duan_sun(t,p2*1.D-5,henry,xphi,lngamco2,m_na,m_cl, &
      sat_pressure*1.D-5)
    Qkco2 = henry*xphi  ! convert from bar to Pa
    henry = 1.D0/(FMWH2O*1.D-3)/(henry*1.D-5)/xphi 
    if(present(xphico2)) xphico2 = xphi
   
    mco2 = (p - sat_pressure)*1.D-5*Qkco2
    xco2eq = mco2/(1.D3/fmwh2o + mco2 + m_nacl) 
!   question here: m_nacl or m_na+m_cl ?
   
    select case(iphase)     
    case(1)
      aux_var%xmol(4) = aux_var%xmol(2)*henry/p   
      aux_var%xmol(3) = 1.D0-aux_var%xmol(4)
      if (aux_var%xmol(3) < 0.D0) aux_var%xmol(3) = 0.D0
!     if(xmol(3) < 0.D0) xmol(3) = 0.D0
    case(2)   
      aux_var%xmol(2) = p*aux_var%xmol(4)/henry
      aux_var%xmol(1) = 1.D0 - aux_var%xmol(2)
    case(3)
      temp= sat_pressure/p
      aux_var%xmol(2) = xco2eq
      aux_var%xmol(1) = 1.D0 - xco2eq
      aux_var%xmol(3) = temp
      aux_var%xmol(4) = 1.D0 - temp            
    end select
    aux_var%avgmw(2) = aux_var%xmol(3)*FMWH2O + aux_var%xmol(4)*FMWCO2
    pw = p
    call wateos_noderiv(t,pw,dw_kg,dw_mol,hw,option%scale,ierr) 
    aux_var%den(2) = 1.D0/(aux_var%xmol(4)/dg + aux_var%xmol(3)/dw_mol)
    aux_var%h(2) = hg  
    aux_var%u(2) = hg - p/dg*option%scale
    aux_var%pc(2) = 0.D0

!   aux_var%diff(option%nflowspec+1:option%nflowspec*2) = 2.13D-5
    aux_var%diff(option%nflowspec+1:option%nflowspec*2) = &
      fluid_properties%gas_diffusion_coefficient
!       fluid_properties%diff_base(2)
! Note: not temperature dependent yet.       
    aux_var%zco2=aux_var%den(2)/(p/IDEAL_GAS_CONST/(t+273.15D0)*1.D-3)
!***************  Liquid phase properties **************************
 
!    avgmw(1)= xmol(1)* FMWH2O + xmol(2) * FMWCO2 
    aux_var%h(1) = hw
    aux_var%u(1) = aux_var%h(1) - pw /dw_mol*option%scale
    aux_var%diff(1:option%nflowspec) = fluid_properties%diffusion_coefficient
  ! fluid_properties%diff_base(1)

  
    xm_nacl = m_nacl*FMWNACL
    xm_nacl = xm_nacl/(1.D3 + xm_nacl)
    call nacl_den(t,p*1D-6,xm_nacl,dw_kg) 
    dw_kg = dw_kg*1.D3
!   call nacl_vis(t,p*1.D-6,xm_nacl,visl)
    call VISW(t,pw,sat_pressure,visl,dvdt,dvdp,ierr)

!FEHM mixing ****************************
!  den(1) = xmol(2)*dg + xmol(1)*dw_mol
!  ideal mixing    
!  den(1) = 1.D0/(xmol(2)/dg + xmol(1)/dw_mol) !*c+(1-c)* 

!  m_nacl=option%m_nacl
!  if (reaction%species_idx%na_ion_id /= 0 .and. reaction%species_idx%cl_ion_id /= 0) then
!    m_na = rt_auxvar%pri_molal(reaction%species_idx%na_ion_id)
!    m_cl = rt_auxvar%pri_molal(reaction%species_idx%cl_ion_id)
!    m_nacl = m_na
!    if(m_cl > m_nacl) m_nacl=m_cl
!  endif  

    y_nacl = m_nacl/(m_nacl + 1.D3/FMWH2O)
! **  xmol(1) = xh2o + xnacl
    aux_var%avgmw(1) = aux_var%xmol(1)*((1.D0 - y_nacl)*FMWH2O &
       + y_nacl*FMWNACL) + aux_var%xmol(2)*FMWCO2

!duan mixing **************************
#ifdef DUANDEN
!                 units: t [C], p [MPa], dw_kg [kg/m^3]
  call duan_mix_den (t,p,aux_var%xmol(2),y_nacl,aux_var%avgmw(1),dw_kg,aux_var%den(1))
#endif 

! Garcia mixing **************************
#ifdef GARCIA
  vphi = 1D-6*(37.51D0 + t &
       *(-9.585D-2 + t*(8.74D-4 - t*5.044D-7)))
  aux_var%den(1) = dw_kg/(1D0-(FMWCO2*1.D-3-dw_kg*vphi) &
       *aux_var%xmol(2)/(aux_var%avgmw(1)*1.D-3))
  aux_var%den(1) = aux_var%den(1)/aux_var%avgmw(1)
#endif  
       
 ! Hebach, J. Chem.Eng.Data 2004 (49),p950 ***********
 !   den(1) = 949.7109D0 + p*(0.559684D-6 - 0.00097D-12*p) &  
 !      + (t+273.15)*(0.883148 - 0.00228*(t+273.15))  
 !  den(1) = dw_kg + (den(1)-dw_kg)*xmol(2)/p*henry
 !  den(1) = den(1)/avgmw(1)
!****************************** 2 phase S-Pc-kr relation *********************************
    if (option%nphase >= 2) then
      if (saturation_function%hysteresis_id <= 0.1D0) then 
        call pckrNH_noderiv(aux_var%sat,aux_var%pc,kr, &
                                   saturation_function, &
                                   option)
        pw=p !-pc(1)
     
      else
        call pckrHY_noderiv(aux_var%sat,aux_var%hysdat,aux_var%pc,kr, &
                                   saturation_function, &
                                   option)
      end if
    endif

!    call SaturationFunctionCompute(aux_var%pres,aux_var%sat,kr, &
!                                   ds_dp,dkr_dp, &
!                                   saturation_function, &
!                                   por,perm, &
!                                   option)
    aux_var%kvr(2) = kr(2)/visg     
    aux_var%kvr(1) = kr(1)/visl
    aux_var%vis(2) = visg     
    aux_var%vis(1) = visl
    select case(iphase)
      case(1)
        aux_var%pc =0.D0
      case(2)
        aux_var%pc =0.D0
    end select          

end subroutine MphaseAuxVarCompute_NINC



subroutine MphaseAuxVarCompute_WINC(x, delx, aux_var, global_auxvar,iphase,saturation_function, &
                                    fluid_properties,option)

  use Option_module
  use Global_Aux_module
  use water_eos_module
  use Saturation_Function_module
  use Fluid_module
  
  implicit none

  type(option_type) :: option
  type(fluid_property_type) :: fluid_properties
  type(saturation_function_type) :: saturation_function
  PetscReal :: x(option%nflowdof), xx(option%nflowdof), delx(option%nflowdof)
  type(mphase_auxvar_elem_type) :: aux_var(1:option%nflowdof)
  type(global_auxvar_type) :: global_auxvar

  PetscInt :: iphase

  PetscInt :: n 
  
  do n=1, option%nflowdof
     xx=x;  xx(n)=x(n)+ delx(n)
! ***   note: var_node here starts from 1 to option%flowdof ***
    call  MphaseAuxVarCompute_NINC(xx,aux_var(n),global_auxvar,iphase, &
                                   saturation_function, &
                                   fluid_properties, option)
  enddo

end subroutine MphaseAuxVarCompute_WINC

! ************************************************************************** !
! 
! MphaesSecHeatAuxVarCompute: Computes secondary auxillary variables in each
!                             grid cell for heat transfer only
! author: Satish Karra
! Date: 06/28/12
!
! ************************************************************************** !

#ifdef MC_HEAT
subroutine MphaseSecHeatAuxVarCompute(sec_heat_vars,global_aux_var, &
                                   therm_conductivity,dencpr,area_fm, &
                                   option)

  use Option_module 
  use Global_Aux_module
  
  implicit none
  
  type(sec_heat_type) :: sec_heat_vars
  type(global_auxvar_type) :: global_aux_var
  type(option_type) :: option
  PetscReal, allocatable :: coeff_left(:), coeff_diag(:), coeff_right(:)
  PetscReal, allocatable :: rhs(:), sec_temp(:)
  PetscInt :: i, ngcells
  PetscReal :: area, vol, gsize, area_fm
  PetscReal :: alpha, therm_conductivity, dencpr
  PetscReal :: temp_primary_node
  PetscReal :: m
  
  ngcells = sec_heat_vars%ncells
  area = sec_heat_vars%area
  vol = sec_heat_vars%vol
  gsize = sec_heat_vars%grid_size
  temp_primary_node = global_aux_var%temp(1)

  allocate(coeff_left(ngcells))
  allocate(coeff_diag(ngcells))
  allocate(coeff_right(ngcells))
  allocate(rhs(ngcells))
  allocate(sec_temp(ngcells))
  
  coeff_left = 0.d0
  coeff_diag = 0.d0
  coeff_right = 0.d0
  rhs = 0.d0
  sec_temp = 0.d0
  
  alpha = option%flow_dt*therm_conductivity/dencpr

  
  ! Setting the coefficients
  do i = 2, ngcells-1
    coeff_left(i) = -alpha*area/(gsize*vol)
    coeff_diag(i) = 2.d0*alpha*area/(gsize*vol) + 1.d0
    coeff_right(i) = -alpha*area/(gsize*vol)
  enddo
  
  coeff_diag(1) = alpha*area/(gsize*vol) + 1.d0
  coeff_right(1) = -alpha*area/(gsize*vol)
  
  coeff_left(ngcells) = -alpha*area/(gsize*vol)
  coeff_diag(ngcells) = alpha*area/(gsize*vol) + &
                        alpha*area/(gsize*vol/2.d0) + 1.d0
                        
  rhs = sec_heat_vars%sec_temp  ! secondary continuum values from previous time step
  rhs(ngcells) = rhs(ngcells) + & 
                 alpha*area/(gsize*vol/2.d0)*temp_primary_node
                
  ! Thomas algorithm for tridiagonal system
  ! Forward elimination
  do i = 2, ngcells
    m = coeff_left(i)/coeff_diag(i-1)
    coeff_diag(i) = coeff_diag(i) - m*coeff_right(i-1)
    rhs(i) = rhs(i) - m*rhs(i-1)
  enddo

  ! Back substitution
  ! Calculate temperature in the secondary continuum
  sec_temp(ngcells) = rhs(ngcells)/coeff_diag(ngcells)
  do i = ngcells-1, 1, -1
    sec_temp(i) = (rhs(i) - coeff_right(i)*sec_temp(i+1))/coeff_diag(i)
  enddo
  
  sec_heat_vars%sec_temp = sec_temp
      
end subroutine MphaseSecHeatAuxVarCompute
#endif

! ************************************************************************** !
!
! MphaseAuxVarElemDestroy: Deallocates a mphase auxilliary elment object
! author: 
! date: 
!
! ************************************************************************** !
subroutine MphaseAuxVarElemDestroy(aux_var_elem)

  implicit none

  type(mphase_auxvar_elem_type) :: aux_var_elem

  if (associated(aux_var_elem%xmol)) deallocate(aux_var_elem%xmol)
  nullify(aux_var_elem%xmol)
  if (associated(aux_var_elem%diff))deallocate(aux_var_elem%diff)
  nullify(aux_var_elem%diff)
  if (associated(aux_var_elem%pc))deallocate(aux_var_elem%pc)
  nullify(aux_var_elem%pc)
  if (associated(aux_var_elem%sat))deallocate(aux_var_elem%sat)
  nullify(aux_var_elem%sat)
  if (associated(aux_var_elem%u))deallocate(aux_var_elem%u)
  nullify(aux_var_elem%u)
  if (associated(aux_var_elem%h))deallocate(aux_var_elem%h)
  nullify(aux_var_elem%h)
  if (associated(aux_var_elem%den))deallocate(aux_var_elem%den)
  nullify(aux_var_elem%den)
  if (associated(aux_var_elem%den))deallocate(aux_var_elem%vis)
  nullify(aux_var_elem%vis)
  if (associated(aux_var_elem%avgmw))deallocate(aux_var_elem%avgmw)
  nullify(aux_var_elem%avgmw)

end subroutine MphaseAuxVarElemDestroy

! ************************************************************************** !
!
! MphaseAuxVarDestroy: Deallocates a mphase auxilliary object
! author: 
! date: 
!
! ************************************************************************** !
subroutine MphaseAuxVarDestroy(aux_var)

  implicit none

  type(mphase_auxvar_type) :: aux_var

  PetscInt :: ielem

  ! subtract 1 since indexing from 0
  if (associated(aux_var%aux_var_elem)) then
    do ielem = 0, size(aux_var%aux_var_elem) - 1 
      call MphaseAuxVarElemDestroy(aux_var%aux_var_elem(ielem))
    enddo
    deallocate(aux_var%aux_var_elem)
    nullify(aux_var%aux_var_elem)
  endif

end subroutine MphaseAuxVarDestroy

! ************************************************************************** !
!
! MphaseAuxDestroy: Deallocates a mphase auxilliary object
! author: 
! date: 
!
! ************************************************************************** !
subroutine MphaseAuxDestroy(aux)

  implicit none

  type(mphase_type), pointer :: aux

  PetscInt :: iaux
  
  if (.not.associated(aux)) return

  if (associated(aux%aux_vars)) then
    do iaux = 1, aux%num_aux
      call MphaseAuxVarDestroy(aux%aux_vars(iaux))
    enddo
    deallocate(aux%aux_vars)
    nullify(aux%aux_vars)
  endif
  
  if (associated(aux%aux_vars_bc)) then
    do iaux = 1, aux%num_aux_bc
      call MphaseAuxVarDestroy(aux%aux_vars_bc(iaux))
    enddo
    deallocate(aux%aux_vars_bc)
    nullify(aux%aux_vars_bc)
  endif
  
  if (associated(aux%aux_vars_ss)) then
    do iaux = 1, aux%num_aux_ss
      call MphaseAuxVarDestroy(aux%aux_vars_ss(iaux))
    enddo
    deallocate(aux%aux_vars_ss)
    nullify(aux%aux_vars_ss)
  endif
  
  if (associated(aux%zero_rows_local)) deallocate(aux%zero_rows_local)
  nullify(aux%zero_rows_local)
  if (associated(aux%zero_rows_local_ghosted)) deallocate(aux%zero_rows_local_ghosted)
  nullify(aux%zero_rows_local_ghosted)
  if (associated(aux%mphase_parameter)) then
    if (associated(aux%mphase_parameter%dencpr)) deallocate(aux%mphase_parameter%dencpr)
    nullify(aux%mphase_parameter%dencpr)
    if (associated(aux%mphase_parameter%ckwet)) deallocate(aux%mphase_parameter%ckwet)
    nullify(aux%mphase_parameter%ckwet)
    if (associated(aux%mphase_parameter%sir)) deallocate(aux%mphase_parameter%sir)
    nullify(aux%mphase_parameter%sir)
    deallocate(aux%mphase_parameter)
  endif
  nullify(aux%mphase_parameter)
  if (associated(aux%res_old_AR)) deallocate(aux%res_old_AR)
  if (associated(aux%res_old_FL)) deallocate(aux%res_old_FL)
  if (associated(aux%delx)) deallocate(aux%delx)
  
  deallocate(aux)
  nullify(aux)
  
end subroutine MphaseAuxDestroy

end module Mphase_Aux_module


